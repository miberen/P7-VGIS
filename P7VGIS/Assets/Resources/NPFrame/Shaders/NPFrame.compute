// Declare kernels, these are basically method declarations Unity uses to access the shader.
#pragma kernel MakePow2
#pragma kernel MakeNPow2
#pragma kernel Analyze2x2Box
#pragma kernel Analyze4x4Box
#pragma kernel AnalyzeBQBS
#pragma kernel Synthesize2x2Box
#pragma kernel SynthesizeBQBS
#pragma kernel DOF
//#pragma kernel Infill
 
// Declare kernel functions
float4 ApplyKernel(uint2 id, float3x3 kernel);
float4 ApplyKernel0_0(uint2 id);
float4 ApplyKernel0_1(uint2 id);
float4 ApplyKernel1_0(uint2 id);
float4 ApplyKernel1_1(uint2 id);

// Variables for changing sampling mode, clamp ignores UV inputs above 1 or below 0, repeat wraps around.
SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;

// Uniforms for source and destination textures, Texture2D for read only on source, RWTexture2D for write access to destination texture
Texture2D<float4> source;
Texture2D<float4> depth;
RWTexture2D<float4> dest;
//Texture2D<float4> infillRead;

// Uniforms for DOF 
float focalLength;
float focalSize;
float aperture;
float nearClipPlane;
float farClipPlane;
int firstPass;
int lastPass;
float4 blurPlanes;
Texture2D<float4> DOF0;
Texture2D<float4> DOF1;
int debug;
// Uniforms for infill effect
int isRange;
float4 infillColor;
float4 infillLowRange;
float4 infillHighRange;

// Offset to stop bleeding
static uint2 offset = uint2(64, 64);


float Remap(float value, float from1, float to1, float from2, float to2)
{
	return from2 + (value - from1) * (to2 - from2) / (to1 - from1);
}

float4 Lerp(float factor, float4 a, float4 b)
{
	return float4(factor * a.r + (1.0 - factor) * b.r, factor * a.g + (1.0 - factor) * b.g, factor * a.b + (1.0 - factor) * b.b, 1.0);
}

float InterpolateValue(float value, float scale, float x, float y)
{
	return 1-((value*scale - x) / (y-x));
}

// Kernels for synthesize function
static float3x3 kernel0_0 =
{	
	0,0,0,
	3,9,0,
	1,3,0
};

static float3x3 kernel0_1 =
{	
	1,3,0,
	3,9,0,
	0,0,0
};

static float3x3 kernel1_0 =
{	
	0,0,0,
	0,9,3,
	0,3,1
};

static float3x3 kernel1_1 =
{	
	0,3,1,
	0,9,3,
	0,0,0
};

// Copies source into a new power of 2 destination texture, also pads the image with edge pixels
[numthreads(32,32,1)]
void MakePow2 (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    source.GetDimensions(sW, sH);	

	// Copies BOTTOM LEFT corner pixel
	if(id.x < offset.x && id.y < offset.y)
		dest[id] = source[uint2(0, 0)];
	// Copies BOTTOM RIGHT corner pixel
	else if(id.x >= sW + offset.x && id.y < offset.y)
		dest[id] = source[uint2(sW - 1, 0)];
	// Copies TOP LEFT corner pixel
	else if(id.x < offset.x && id.y >= sH + offset.y)
		dest[id] = source[uint2(0, sH - 1)];
	// Copies BOTTOM EDGE
	else if(id.y < offset.y)
		dest[id] = source[uint2(id.x - offset.x, 0)];
	// Copies LEFT EDGE
	else if(id.x < offset.x)
		dest[id] = source[uint2(0, id.y - offset.y)];
	// Copies TOP RIGHT corner pixel
    if(id.x >= sW && id.y >= sH)
		dest[id + offset] = source[uint2(sW-1, sH-1)];
	// Copies TOP EDGE
    else if(id.y >= sH)
		dest[id + offset] = source[uint2(id.x, sH-1)];
	// Copies RIGHT EDGE
    else if(id.x >= sW)
		dest[id + offset] = source[uint2(sW-1, id.y)];
	//Actual image
    else dest[id + offset] = source[id];

}


[numthreads(32, 32, 1)]
void MakeNPow2 (uint2 id : SV_DispatchThreadID)
{
    dest[id] = source[id + offset];
}


[numthreads(32,32,1)]
void Analyze2x2Box (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = source.SampleLevel(_LinearClamp, uv + (texelSize / 2), 0);
}

[numthreads(32,32,1)]
void Analyze4x4Box (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = (source.SampleLevel(_LinearClamp, uv, 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y + texelSize.y), 0)
			   ) / 4;
	
}

[numthreads(32,32,1)]
void AnalyzeBQBS (uint2 id : SV_DispatchThreadID)
{
	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);
	
	dest[id] = (source.SampleLevel(_LinearClamp, float2(uv + texelSize / 8), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / 8, uv.y + texelSize.y / 8), 0) +
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x / 8, uv.y + texelSize.y - texelSize.y / 8), 0) + 
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / 8, uv.y + texelSize.y - texelSize.y / 8), 0)
			   ) / 4;
}



[numthreads(32,32,1)]
void Synthesize2x2Box (uint2 id : SV_DispatchThreadID)
{	
    uint sW, sH;
    source.GetDimensions(sW, sH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);

	dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, uv, 0);
	dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y) , 0);
	dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y), 0);
	dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y + texelSize.y), 0);
}

[numthreads(32,32,1)]
void SynthesizeBQBS (uint2 id : SV_DispatchThreadID)
{	
    uint sW, sH;
    source.GetDimensions(sW, sH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);

	dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv + texelSize/4), 0);
	dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y/4) , 0);
	dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);
	dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);
}

[numthreads(32,32,1)]
void DOF (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    dest.GetDimensions(sW, sH);
	uint dW, dH;
    DOF0.GetDimensions(dW, dH);
	float2 uv = float2(Remap(id.x + offset.x, 0, sW, 0, dW) / dW, Remap(id.y + offset.y, 0, sH, 0, dH) / dH);
	if(firstPass == 1)
	{
		if((depth[id].r * farClipPlane <= focalLength + focalSize + nearClipPlane && depth[id].r * farClipPlane >= focalLength - focalSize + nearClipPlane))
		{
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		}
	}

	if(firstPass == 0) 
	{
		if(depth[id].r * farClipPlane > blurPlanes.x  && depth[id].r * farClipPlane < blurPlanes.y)
		{
			float p1;
			p1 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.x, blurPlanes.y);			
			dest[id + offset] = Lerp(p1, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);  
		}
		if(depth[id].r * farClipPlane < blurPlanes.z && depth[id].r * farClipPlane > blurPlanes.w)
		{
			float p2 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.z, blurPlanes.w);
			dest[id + offset] = Lerp(p2, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);
		}
		if(depth[id].r * farClipPlane > blurPlanes.y && lastPass == 1)
			dest[id+offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		if(depth[id].r * farClipPlane < blurPlanes.w && lastPass == 1)
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
	}
}

//[numthreads(32,32,1)]
//void Infill (uint2 id : SV_DispatchThreadID, uint id1D : SV_GroupIndex)
//{	
//	uint sW, sH;
//    source.GetDimensions(sW, sH);
//	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
//	float2 texelSize = float2((float)1/sW, (float)1/sH);
//	float4 compare = dest.Load(id1D);
//	if(isRange == 1)
//	{
//		//dest[id] = source.SampleLevel(_PointClamp, uv, 0);
//		dest[id] = float4(1,0,0,1);
//	}
//	else if(compare.x == infillColor.x && compare.y == infillColor.y && compare.z == infillColor.z)
//	{	
//		dest[id] = float4(1,0,0,1);
//		//dest[id] = source.SampleLevel(_PointClamp, uv, 0);
//	}
//}

float4 ApplyKernel(uint2 id, float3x3 kernel)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * kernel[2][0];
	sum += source[id + int2(0.0 ,-1.0)] * kernel[2][1];
	sum += source[id + int2(1.0, -1.0)] * kernel[2][2];
	sum += source[id + int2(-1.0, 0.0)] * kernel[1][0];
	sum += source[id + int2( 0.0, 0.0)] * kernel[1][1];
	sum += source[id + int2( 1.0, 0.0)] * kernel[1][2];
	sum += source[id + int2(-1.0, 1.0)] * kernel[0][0];
	sum += source[id + int2( 0.0, 1.0)] * kernel[0][1];
	sum += source[id + int2( 1.0, 1.0)] * kernel[0][2];

	return sum/16;
}

float4 ApplyKernel0_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * 1;
	sum += source[id + int2(0.0 ,-1.0)] * 3;
	sum += source[id + int2(-1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 0.0)] * 9;


	return sum/16;
}

float4 ApplyKernel0_1(uint2 id)
{
	float4 sum = 0;
 
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( -1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 1.0)] * 3;
	sum += source[id + int2( -1.0, -1.0)] * 1;

	return sum/16;
}

float4 ApplyKernel1_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, -1.0)] * 3;
	sum += source[id + int2( 1.0, -1.0)] * 1;
	
	return sum/16;
}

float4 ApplyKernel1_1(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(0.0 ,1.0)] * 3;
	sum += source[id + int2(1.0, 1.0)] * 1;
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;

	return sum/16;
}
 /*
 int3 CnvRBGtoYCbCr(float4 RBGColor) 
 {
	int y;
	int cb;
	int cr;

	y = (RBGColor.r * 256 * 0.229 ) + (RBGColor.g * 256 * 0.587) + (RBGColor.b * 256 * 0.114);
	cb = 128 + (-0.169 * RBGColor.r * 256) + (-0.331 * RBGColor.g * 256) + (0.5 * RBGColor.b * 256);
	cr = 128 + (0.5* RBGColor.r * 256) + (-0.419 * RBGColor.g * 256) + (-0.081 * RBGColor.b * 256);

 	return int3(y, cb, cr);
 }

 float4 CnvYCbCrtoRBG(int3 YCbCr)
 {
	float r;
	float g;
	float b;

	r = ((1*YCbCr.x)+(1.4*(YCbCr.z-128)))/256;
	g = ((1*YCbCr.x)+(-0.343*(YCbCr.y-128))+(-0.711*(YCbCr.z-128)))/256;
	b = ((1*YCbCr.x)+(1.765*(YCbCr.y-128)))/256;

	return float4(r, g, b, 1);
 }

 int histogram[256] = 0;
 int cumHistogram[256] = 0;
 int lut[256] = 0;
 int minvalue = 0;
 int totalpixels = source.width * source.heigth;

 histogram[CnvRBGtoYCbCr(source[id]).x] += 1; // histogram[CnvRBGtoYCbCr(source[id]).x] + 1;
 cumHistogram[0] = histogram[0];

 for(int i = 1; i <= 255; i++)
 {
	cumHistogram[i] = cumHistogram[i-1] + histogram[i];
 }

 for(int i = 0; i <= 255; i++)
 {
	if(cumHistogram[i] 1= 0 && minvalue == 0)
		minvalue = cumHistogram[i];
 }

 for(int i = i; i <= 255; i++)
 {
	lut[i] = (cumHistogram[i] - minvalue)/(totalpixels - minvalue)*256;
 }

 int3 oldYCbCrvalue = CnvRBGtoYCbCr(source[id]);
 int3 newYCbCrvalue = int3(lut[oldYCbCrvalue.x], oldYCbCrvalue.y, oldYCbCrvalue.z]
 dest[id] = CnvYCbCrtoRGB(newYCbCrvalue);
 */	
