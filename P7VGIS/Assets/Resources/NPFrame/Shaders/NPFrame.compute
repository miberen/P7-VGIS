#pragma kernel MakePow2
#pragma kernel MakeNPow2
#pragma kernel Analyze
#pragma kernel Synthesize
#pragma kernel DOF
//#pragma kernel Infill
 
// Declare functions
float4 ApplyKernel(uint2 id, float3x3 kernel);
float4 ApplyKernel0_0(uint2 id);
float4 ApplyKernel0_1(uint2 id);
float4 ApplyKernel1_0(uint2 id);
float4 ApplyKernel1_1(uint2 id);

// Variables for changing billenear sampling mode
SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;

// Uniforms for source and destination textures, Texture2D for read only on source, RWTexture2D for read / write access to destination texture
Texture2D<float4> source;
Texture2D<float4> depth;
RWTexture2D<float4> dest;
//Texture2D<float4> infillRead;

// Uniforms for DOF 
float focalLength;
float focalSize;
float aperture;
float nearClipPlane;
float farClipPlane;
int firstPass;
int lastPass;
float4 blurPlanes;
Texture2D<float4> DOF0;
Texture2D<float4> DOF1;
int debug;
// Uniforms for infill effect
int isRange;
float4 infillColor;
float4 infillLowRange;
float4 infillHighRange;

// Offset to stop bleeding
static uint2 offset = uint2(64, 64);


float Remap(float value, float from1, float to1, float from2, float to2)
{
	return from2 + (value - from1) * (to2 - from2) / (to1 - from1);
}

float4 Lerp(float factor, float4  a, float4 b)
{
	//if(factor > 1) factor = 1;
	return float4(factor * a.r + (1.0 - factor) * b.r, factor * a.g + (1.0 - factor) * b.g, factor * a.b + (1.0 - factor) * b.b, 1.0);
}

float InterpolateValue(float value, float scale, float x, float y)
{
	return 1-((value*scale - x) / (y-x));
}

// Kernels for synthesize function
static float3x3 kernel0_0 =
{	
	0,0,0,
	3,9,0,
	1,3,0
};

static float3x3 kernel0_1 =
{	
	1,3,0,
	3,9,0,
	0,0,0
};

static float3x3 kernel1_0 =
{	
	0,0,0,
	0,9,3,
	0,3,1
};

static float3x3 kernel1_1 =
{	
	0,3,1,
	0,9,3,
	0,0,0
};

// Copies source into a new power of 2 destination texture, also pads the image with edge pixels
[numthreads(32,32,1)]
void MakePow2 (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    source.GetDimensions(sW, sH);	

	// Copies BOTTOM LEFT corner pixel
	if(id.x < offset.x && id.y < offset.y)
		dest[id] = source[uint2(0, 0)];
	// Copies BOTTOM RIGHT corner pixel
	else if(id.x >= sW + offset.x && id.y < offset.y)
		dest[id] = source[uint2(sW - 1, 0)];
	// Copies TOP LEFT corner pixel
	else if(id.x < offset.x && id.y >= sH + offset.y)
		dest[id] = source[uint2(0, sH - 1)];
	// Copies BOTTOM EDGE
	else if(id.y < offset.y)
		dest[id] = source[uint2(id.x - offset.x, 0)];
	// Copies LEFT EDGE
	else if(id.x < offset.x)
		dest[id] = source[uint2(0, id.y - offset.y)];
	// Copies TOP RIGHT corner pixel
    if(id.x >= sW && id.y >= sH)
		dest[id + offset] = source[uint2(sW-1, sH-1)];
	// Copies TOP EDGE
    else if(id.y >= sH)
		dest[id + offset] = source[uint2(id.x, sH-1)];
	// Copies RIGHT EDGE
    else if(id.x >= sW)
		dest[id + offset] = source[uint2(sW-1, id.y)];
	//Actual image
    else dest[id + offset] = source[id];

}


[numthreads(32, 32, 1)]
void MakeNPow2 (uint2 id : SV_DispatchThreadID)
{
    dest[id] = source[id + offset];
}


[numthreads(32,32,1)]
void Analyze (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = source.SampleLevel(_LinearClamp, uv + (texelSize / 2), 0);
}

[numthreads(32,32,1)]
void Analyze16Point (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = (source.SampleLevel(_LinearClamp, uv, 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x * 2, uv.y), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y * 2), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x * 2, uv.y + texelSize.y * 2), 0)
			   )/4;
}

[numthreads(32,32,1)]
void Synthesize (uint2 id : SV_DispatchThreadID)
{	
    uint sW, sH;
    source.GetDimensions(sW, sH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);

	dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv + texelSize/4), 0);
	dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y/4) , 0);
	dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);
	dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);

	//dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, uv, 0);
	//dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y) , 0);
	//dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y), 0);
	//dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y + texelSize.y), 0);

 //   dest[2*id+uint2(0.0, 0.0)] = ApplyKernel(id, kernel0_0);
	//dest[2*id+uint2(0.0, 1.0)] = ApplyKernel(id, kernel0_1);
	//dest[2*id+uint2(1.0, 0.0)] = ApplyKernel(id, kernel1_0);
	//dest[2*id+uint2(1.0, 1.0)] = ApplyKernel(id, kernel1_1);

	//dest[2*id+uint2(0.0, 0.0)] = ApplyKernel0_0(id);
	//dest[2*id+uint2(0.0, 1.0)] = ApplyKernel0_1(id);
	//dest[2*id+uint2(1.0, 0.0)] = ApplyKernel1_0(id);
	//dest[2*id+uint2(1.0, 1.0)] = ApplyKernel1_1(id);
}

[numthreads(32,32,1)]
void DOF (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    dest.GetDimensions(sW, sH);
	uint dW, dH;
    DOF0.GetDimensions(dW, dH);
	float2 uv = float2(Remap(id.x + offset.x, 0, sW, 0, dW) / dW, Remap(id.y + offset.y, 0, sH, 0, dH) / dH);
	if(firstPass == 1){
		if((depth[id].r * farClipPlane <= focalLength + focalSize + nearClipPlane && depth[id].r * farClipPlane >= focalLength - focalSize + nearClipPlane))
		{
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		}
	}

	if(firstPass == 0) {
		if(depth[id].r * farClipPlane > blurPlanes.x  && depth[id].r * farClipPlane < blurPlanes.y)
		{
			float p1;
			p1 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.x, blurPlanes.y);			
			dest[id + offset] = Lerp(p1, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);  
		}
		if(depth[id].r * farClipPlane < blurPlanes.z && depth[id].r * farClipPlane > blurPlanes.w)
		{
			float p2 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.z, blurPlanes.w);
			dest[id + offset] = Lerp(p2, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);
		}
		if(depth[id].r * farClipPlane > blurPlanes.y && lastPass == 1)
			dest[id+offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		if(depth[id].r * farClipPlane < blurPlanes.w && lastPass == 1)
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
	}
}

//[numthreads(32,32,1)]
//void Infill (uint2 id : SV_DispatchThreadID, uint id1D : SV_GroupIndex)
//{	
//	uint sW, sH;
//    source.GetDimensions(sW, sH);
//	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
//	float2 texelSize = float2((float)1/sW, (float)1/sH);
//	float4 compare = dest.Load(id1D);
//	if(isRange == 1)
//	{
//		//dest[id] = source.SampleLevel(_PointClamp, uv, 0);
//		dest[id] = float4(1,0,0,1);
//	}
//	else if(compare.x == infillColor.x && compare.y == infillColor.y && compare.z == infillColor.z)
//	{	
//		dest[id] = float4(1,0,0,1);
//		//dest[id] = source.SampleLevel(_PointClamp, uv, 0);
//	}
//}

float4 ApplyKernel(uint2 id, float3x3 kernel)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * kernel[2][0];
	sum += source[id + int2(0.0 ,-1.0)] * kernel[2][1];
	sum += source[id + int2(1.0, -1.0)] * kernel[2][2];
	sum += source[id + int2(-1.0, 0.0)] * kernel[1][0];
	sum += source[id + int2( 0.0, 0.0)] * kernel[1][1];
	sum += source[id + int2( 1.0, 0.0)] * kernel[1][2];
	sum += source[id + int2(-1.0, 1.0)] * kernel[0][0];
	sum += source[id + int2( 0.0, 1.0)] * kernel[0][1];
	sum += source[id + int2( 1.0, 1.0)] * kernel[0][2];

	return sum/16;
}

float4 ApplyKernel0_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * 1;
	sum += source[id + int2(0.0 ,-1.0)] * 3;
	sum += source[id + int2(-1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 0.0)] * 9;


	return sum/16;
}

float4 ApplyKernel0_1(uint2 id)
{
	float4 sum = 0;
 
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( -1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 1.0)] * 3;
	sum += source[id + int2( -1.0, -1.0)] * 1;

	return sum/16;
}

float4 ApplyKernel1_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, -1.0)] * 3;
	sum += source[id + int2( 1.0, -1.0)] * 1;
	
	return sum/16;
}

float4 ApplyKernel1_1(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(0.0 ,1.0)] * 3;
	sum += source[id + int2(1.0, 1.0)] * 1;
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;

	return sum/16;
}
