#pragma kernel MakePow2
#pragma kernel MakeNPow2
#pragma kernel Analyze2x2Box
#pragma kernel Analyze4x4Box
#pragma kernel AnalyzeBQBS
#pragma kernel SynthesizeBQBS
#pragma kernel DOF
#pragma kernel Blur
#pragma kernel HistogramEq
#pragma kernel ApplyCustom
#pragma kernel Bloom
 
// Declare functions
float4 ApplyKernel(uint2 id);
int3 CnvRGBtoYCbCr(float4 RBGColor);
float4 CnvYCbCrtoRGB(int3 YCbCr); 
void ApplyBilinearLookup(uint2 id, float2 uv, float2 texelSize, int lookup, int type);

// Variables for changing billenear sampling mode
SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;

// Uniforms for source and destination textures, Texture2D for read only on source, RWTexture2D for read / write access to destination texture
Texture2D<float4> source;
Texture2D<float4> depth;
RWTexture2D<float4> dest;
//Texture2D<float4> infillRead;

// Uniforms for DOF 
float focalLength;
float focalSize;
float aperture;
float nearClipPlane;
float farClipPlane;
int firstPass;
int lastPass;
float4 blurPlanes;
Texture2D<float4> DOF0;
Texture2D<float4> DOF1;

// Uniforms for applying custom kernel;
uniform StructuredBuffer<int> kernel;
int kernelSize;
int filterFactor;

// Uniforms for bloom effect
Texture2D<float4> bloom;
uint bloomValue;
float bloomStrength;

// Offset to stop bleeding
static uint2 offset = uint2(64, 64);


float Remap(float value, float from1, float to1, float from2, float to2)
{
	return from2 + (value - from1) * (to2 - from2) / (to1 - from1);
}

float4 Lerp(float factor, float4 a, float4 b)
{
	return float4(factor * a.r + (1.0 - factor) * b.r, factor * a.g + (1.0 - factor) * b.g, factor * a.b + (1.0 - factor) * b.b, factor * a.a + (1.0 - factor) * b.a);
}

float InterpolateValue(float value, float scale, float x, float y)
{
	return 1-((value*scale - x) / (y-x));
}


// Copies source into a new power of 2 destination texture, also pads the image with edge pixels
[numthreads(32,32,1)]
void MakePow2 (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    source.GetDimensions(sW, sH);	

	// Copies BOTTOM LEFT corner pixel
	if(id.x < offset.x && id.y < offset.y)
		dest[id] = source[uint2(0, 0)];
	// Copies BOTTOM RIGHT corner pixel
	else if(id.x >= sW + offset.x && id.y < offset.y)
		dest[id] = source[uint2(sW - 1, 0)];
	// Copies TOP LEFT corner pixel
	else if(id.x < offset.x && id.y >= sH + offset.y)
		dest[id] = source[uint2(0, sH - 1)];
	// Copies BOTTOM EDGE
	else if(id.y < offset.y)
		dest[id] = source[uint2(id.x - offset.x, 0)];
	// Copies LEFT EDGE
	else if(id.x < offset.x)
		dest[id] = source[uint2(0, id.y - offset.y)];
	// Copies TOP RIGHT corner pixel
    if(id.x >= sW && id.y >= sH)
		dest[id + offset] = source[uint2(sW-1, sH-1)];
	// Copies TOP EDGE
    else if(id.y >= sH)
		dest[id + offset] = source[uint2(id.x, sH-1)];
	// Copies RIGHT EDGE
    else if(id.x >= sW)
		dest[id + offset] = source[uint2(sW-1, id.y)];
	//Actual image
    else dest[id + offset] = source[id];

}

[numthreads(32, 32, 1)]
void MakeNPow2 (uint2 id : SV_DispatchThreadID)
{
    dest[id] = source[id + offset];
}


[numthreads(32,32,1)]
void Analyze2x2Box (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = source.SampleLevel(_LinearClamp, uv + (texelSize / 2), 0);
}

[numthreads(32,32,1)]
void Analyze4x4Box (uint2 id : SV_DispatchThreadID)
{
    //dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;

	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);

	dest[id] = (source.SampleLevel(_LinearClamp, uv, 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y + texelSize.y), 0)
			   ) / 4;
	
}

[numthreads(32,32,1)]
void AnalyzeBQBS (uint2 id : SV_DispatchThreadID)
{
	uint dW, dH;
    dest.GetDimensions(dW, dH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/dW, (float)id.y/dH);
	float2 texelSize = float2((float)1/dW, (float)1/dH);
	
	dest[id] = (source.SampleLevel(_LinearClamp, float2(uv + texelSize / 8), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / 8, uv.y + texelSize.y / 8), 0) +
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x / 8, uv.y + texelSize.y - texelSize.y / 8), 0) + 
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / 8, uv.y + texelSize.y - texelSize.y / 8), 0)
			   ) / 4;
}

[numthreads(32,32,1)]
void SynthesizeBQBS (uint2 id : SV_DispatchThreadID)
{	
    uint sW, sH;
    source.GetDimensions(sW, sH);
	// Cast to float becasue HLSL is stupid and doesn't figure it out  by itself
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);

	dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv + texelSize/4), 0);
	dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y/4) , 0);
	dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);
	dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/4, uv.y + texelSize.y - texelSize.y/4), 0);
}

[numthreads(32,32,1)]
void DOF (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    dest.GetDimensions(sW, sH);
	uint dW, dH;
    DOF0.GetDimensions(dW, dH);
	float2 uv = float2(Remap(id.x + offset.x, 0, sW, 0, dW) / dW, Remap(id.y + offset.y, 0, sH, 0, dH) / dH);
	if(firstPass == 1)
	{
		if((depth[id].r * farClipPlane <= focalLength + focalSize + nearClipPlane && depth[id].r * farClipPlane >= focalLength - focalSize + nearClipPlane))
		{
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		}
	}

	if(firstPass == 0) 
	{
		if(depth[id].r * farClipPlane > blurPlanes.x  && depth[id].r * farClipPlane < blurPlanes.y)
		{
			float p1;
			p1 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.x, blurPlanes.y);			
			dest[id + offset] = Lerp(p1, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);  
		}
		if(depth[id].r * farClipPlane < blurPlanes.z && depth[id].r * farClipPlane > blurPlanes.w)
		{
			float p2 = InterpolateValue(depth[id].r, farClipPlane, blurPlanes.z, blurPlanes.w);
			dest[id + offset] = Lerp(p2, DOF1.SampleLevel(_PointClamp, uv, 0), DOF0.SampleLevel(_PointClamp, uv, 0)); //DOF0.SampleLevel(_PointClamp, uv, 0);
		}
		if(depth[id].r * farClipPlane > blurPlanes.y && lastPass == 1)
			dest[id+offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
		if(depth[id].r * farClipPlane < blurPlanes.w && lastPass == 1)
			dest[id + offset] = DOF0.SampleLevel(_PointClamp, uv, 0);
	}
}

[numthreads(32,32,1)]
void Blur (uint2 id : SV_DispatchThreadID)
{
	dest[id+offset] = source[id+offset];
}

[numthreads(32,32,1)]
void HistogramEq(uint2 id : SV_DispatchThreadID)
{
		 uint sW, sH;
		 source.GetDimensions(sW, sH);
		 int histogram[256];
		 int cumHistogram[256];
		 int lut[256];
		 int minvalue = 0;
		 int totalpixels = sW * sH;
			
	if(firstPass == 1) {	

		for(int i = 0; i <= 255; i++){
		histogram[i] = 0;
		}

		 histogram[CnvRGBtoYCbCr(source[id]).x] += 1; // histogram[CnvRGBtoYCbCr(source[id]).x] + 1;

		 cumHistogram[0] = histogram[0];
		
		 for(int i = 1; i <= 255; i++)
		 {
			cumHistogram[i] = cumHistogram[i-1] + histogram[i];
		 }
		
		 for(int i = 0; i <= 255; i++)
		 {
			if(cumHistogram[i] != 0 && minvalue == 0)
				minvalue = cumHistogram[i];
		 }
		
		 for(int i = 0; i <= 255; i++)
		 {
			lut[i] = (cumHistogram[i] - minvalue)/(totalpixels - minvalue)*256;
		 }
	 }
	
	if(firstPass == 0){
		int3 oldYCbCrvalue = CnvRGBtoYCbCr(source[id]);
		int3 newYCbCrvalue = int3(lut[oldYCbCrvalue.x], oldYCbCrvalue.y, oldYCbCrvalue.z);
		dest[id] = CnvYCbCrtoRGB(newYCbCrvalue);
	 }
	
}

[numthreads(32,32,1)]
void Bloom (uint2 id : SV_DispatchThreadID)
{	
	uint sW, sH;
    dest.GetDimensions(sW, sH);
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);
	
	if(firstPass == 1)
	{
		uint3 ycbcrcolor = CnvRGBtoYCbCr(source.SampleLevel(_LinearClamp, uv, 0));
	
		if(ycbcrcolor.x > bloomValue)
			dest[id] = source.SampleLevel(_PointClamp, uv, 0);
		else 
			dest[id] = float4(0, 0, 0, 0);
	}

	if(firstPass == 0)
	{
		if(!(bloom.SampleLevel(_PointClamp, uv, 0).w == 0))
			dest[id] = bloom.SampleLevel(_PointClamp, uv, 0) + source.SampleLevel(_LinearClamp, uv, 0); //Lerp(bloomStrength, source.SampleLevel(_PointClamp, uv, 0), bloom.SampleLevel(_PointClamp, uv, 0));
		else
			dest[id] = source.SampleLevel(_PointClamp, uv, 0);
	}
}

[numthreads(32,32,1)]
void ApplyCustom (uint2 id : SV_DispatchThreadID)
{

	dest[id + offset] = ApplyKernel(id);

}

void ApplyBilinearLookup(uint2 id, float2 uv, float2 texelSize, int lookup, int type)
{
	[call] switch(type) 
	{
		case 0: 
		{
			dest[id] = (source.SampleLevel(_LinearClamp, float2(uv + texelSize / lookup), 0) +
			    source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / lookup, uv.y + texelSize.y / lookup), 0) +
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x / lookup, uv.y + texelSize.y - texelSize.y / lookup), 0) + 
				source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x / lookup, uv.y + texelSize.y - texelSize.y / lookup), 0)
			   ) / 4;	
		}
		break;

		case 1: 
		{
			dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv + texelSize/lookup), 0);
			dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/lookup, uv.y + texelSize.y/lookup) , 0);
			dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x/lookup, uv.y + texelSize.y - texelSize.y/lookup), 0);
			dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/lookup, uv.y + texelSize.y - texelSize.y/lookup), 0);
		}
		break;

		case 2: 
		{
			dest[id] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x - texelSize.x/lookup, uv.y + texelSize.y/lookup) , 0);
		}
		break;

		default : 
		{
		  dest[id] = float4(0.5, 0, 0.5, 1);
		}
		break;
	}
}

float4 ApplyKernel(uint2 id)
{
	float4 sum = 0;
	int type = kernel[0];
	int filterFactor = kernel[1];
	int kernelSize = kernel[2];

	[call] switch(type) 
	{
		case 0: 
		{
			int enumerator = asint(kernelSize/2);
			int index = 3;
			for(int i = -enumerator+1; i <= enumerator+1; i++)
			{
				for(int j = -enumerator+1; j <= enumerator+1; j++)
				{
					sum += source[id + int2(j, i)] * kernel[index];
					index++;
				}
			}
			sum = sum/filterFactor;
			return sum;
		 }
		 break;

		 case 1: 
		 {
			int enumerator = asint(kernelSize/2);
			int index = 3;
			for(int i = -enumerator; i <= enumerator; i++)
			{
				for(int j = -enumerator; j <= enumerator; j++)
				{
					sum += source[id + int2(j, i)] * kernel[index];
					index++;
				}
			}
			sum = sum/filterFactor;
			return sum;
		 }
		 break;

		 default : 
		 {
		   return float4(0.5, 0, 0.5, 1);
		 }
		 break;
	}
}

 int3 CnvRGBtoYCbCr(float4 RBGColor) 
 {
	int y;
	int cb;
	int cr;

	y = ((RBGColor.r * 0.229 ) + (RBGColor.g * 0.587) + (RBGColor.b * 0.114)) * 256;
	cb = 128 + (-0.169 * RBGColor.r * 256) + (-0.331 * RBGColor.g * 256) + (0.5 * RBGColor.b * 256);
	cr = 128 + (0.5* RBGColor.r * 256) + (-0.419 * RBGColor.g * 256) + (-0.081 * RBGColor.b * 256);

 	return int3(y, cb, cr);
 }

 float4 CnvYCbCrtoRGB(int3 YCbCr)
 {
	float r;
	float g;
	float b;

	r = ((1*YCbCr.x)+(1.4*(YCbCr.z-128)))/256;
	g = ((1*YCbCr.x)+(-0.343*(YCbCr.y-128))+(-0.711*(YCbCr.z-128)))/256;
	b = ((1*YCbCr.x)+(1.765*(YCbCr.y-128)))/256;

	return float4(r, g, b, 1);
 }
