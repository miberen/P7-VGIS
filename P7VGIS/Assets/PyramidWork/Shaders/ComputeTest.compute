#pragma kernel MakePow2
#pragma kernel MakeNPow2
#pragma kernel Analyze
#pragma kernel Synthesize
 
float4 ApplyKernel(uint2 id, float3x3 kernel);
//float4 ApplyKernel0_0(uint2 id);
//float4 ApplyKernel0_1(uint2 id);
//float4 ApplyKernel1_0(uint2 id);
//float4 ApplyKernel1_1(uint2 id);

Texture2D<float4> source;
RWTexture2D<float4> dest;

static float3x3 kernel0_0 =
{	
	0,0,0,
	3,9,0,
	1,3,0
};

static float3x3 kernel0_1 =
{	
	1,3,0,
	3,9,0,
	0,0,0
};

static float3x3 kernel1_0 =
{	
	0,0,0,
	0,9,3,
	0,3,1
};

static float3x3 kernel1_1 =
{	
	0,3,1,
	0,9,3,
	0,0,0
};

[numthreads(32,32,1)]
void MakePow2 (uint2 id : SV_DispatchThreadID)
{
	uint2 offset = uint2(100, 100);
    uint sW, sH;
    source.GetDimensions(sW, sH);
    uint dW, dH;
    dest.GetDimensions(dW, dH);


	// Copies BOTTOM LEFT corner pixel
	if(id.x < offset.x && id.y < offset.y)
		dest[id] = source[uint2(0, 0)];
	// Copies BOTTOM RIGHT corner pixel
	else if(id.x >= sW + offset.x && id.y < offset.y)
		dest[id] = source[uint2(sW - 1, 0)];
	// Copies TOP LEFT corner pixel
	else if(id.x < offset.x && id.y >= sH + offset.y)
		dest[id] = source[uint2(0, sH - 1)];
	// Copies BOTTOM EDGE
	else if(id.y < offset.y)
		dest[id] = source[uint2(id.x - offset.x, 0)];
	// Copies LEFT EDGE
	else if(id.x < offset.x)
		dest[id] = source[uint2(0, id.y - offset.y)];
	// Copies TOP RIGHT corner pixel
    if(id.x >= sW && id.y >= sH)
		dest[id + offset] = source[uint2(sW-1, sH-1)];
	// Copies TOP EDGE
    else if(id.y >= sH)
		dest[id + offset] = source[uint2(id.x, sH-1)];
	// Copies RIGHT EDGE
    else if(id.x >= sW)
		dest[id + offset] = source[uint2(sW-1, id.y)];
	//Actual image
    else dest[id + offset] = source[id];


}

// TODO: Make it work.
[numthreads(32, 32, 1)]
void MakeNPow2 (uint2 id : SV_DispatchThreadID)
{
    dest[id] = source[id + uint2(100, 100)];
}


[numthreads(32,32,1)]
void Analyze (uint2 id : SV_DispatchThreadID)
{
    dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;
}

// TODO: Make it work
[numthreads(32,32,1)]
void Synthesize (uint2 id : SV_DispatchThreadID)
{	
    dest[2*id+uint2(0.0, 0.0)] = ApplyKernel(id, kernel0_0);
	dest[2*id+uint2(0.0, 1.0)] = ApplyKernel(id, kernel0_1);
	dest[2*id+uint2(1.0, 0.0)] = ApplyKernel(id, kernel1_0);
	dest[2*id+uint2(1.0, 1.0)] = ApplyKernel(id, kernel1_1);
}

float4 ApplyKernel(uint2 id, float3x3 kernel)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * kernel[2][0];
	sum += source[id + int2(0.0 ,-1.0)] * kernel[2][1];
	sum += source[id + int2(1.0, -1.0)] * kernel[2][2];
	sum += source[id + int2(-1.0, 0.0)] * kernel[1][0];
	sum += source[id + int2( 0.0, 0.0)] * kernel[1][1];
	sum += source[id + int2( 1.0, 0.0)] * kernel[1][2];
	sum += source[id + int2(-1.0, 1.0)] * kernel[0][0];
	sum += source[id + int2( 0.0, 1.0)] * kernel[0][1];
	sum += source[id + int2( 1.0, 1.0)] * kernel[0][2];

	return sum/16;
}

float4 ApplyKernel0_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * 1;//kernel._m02;
	sum += source[id + int2(0.0 ,-1.0)] * 3;//kernel._m12;
	sum += source[id + int2(1.0, -1.0)] * 0;//kernel._m22;
	sum += source[id + int2(-1.0, 0.0)] * 3;//kernel._m01;
	sum += source[id + int2( 0.0, 0.0)] * 9;//kernel._m11;
	sum += source[id + int2( 1.0, 0.0)] * 0;//kernel._m21;
	sum += source[id + int2(-1.0, 1.0)] * 0;//kernel._m00;
	sum += source[id + int2( 0.0, 1.0)] * 0;//kernel._m10;
	sum += source[id + int2( 1.0, 1.0)] * 0;//kernel._m20;

	return sum/16;
}

float4 ApplyKernel0_1(uint2 id)
{
	float4 sum = 0;
 
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( -1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 1.0)] * 3;
	sum += source[id + int2( -1.0, -1.0)] * 1;

	return sum/16;
}

float4 ApplyKernel1_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, -1.0)] * 3;
	sum += source[id + int2( 1.0, -1.0)] * 1;
	
	return sum/16;
}

float4 ApplyKernel1_1(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(0.0 ,1.0)] * 3;
	sum += source[id + int2(1.0, 1.0)] * 1;
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;

	return sum/16;
}
