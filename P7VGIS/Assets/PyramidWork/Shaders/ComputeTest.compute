#pragma kernel MakePow2
#pragma kernel MakeNPow2
#pragma kernel Analyze
#pragma kernel Synthesize
 
// Declare functions
float4 ApplyKernel(uint2 id, float3x3 kernel);
//float4 ApplyKernel0_0(uint2 id);
//float4 ApplyKernel0_1(uint2 id);
//float4 ApplyKernel1_0(uint2 id);
//float4 ApplyKernel1_1(uint2 id);

// Variables for changing billenear sampling mode
SamplerState _LinearClamp;
SamplerState _LinearRepeat;

// Uniforms for source and destination textures, Texture2D for read only on source, RWTexture2D for read / write access to destination texture
Texture2D<float4> source;
RWTexture2D<float4> dest;

// Uniform for infill effect
float4 infillColor;

// Offset to stop bleeding
static uint2 offset = uint2(50, 50);

// Kernels for synthesize function
static float3x3 kernel0_0 =
{	
	0,0,0,
	3,9,0,
	1,3,0
};

static float3x3 kernel0_1 =
{	
	1,3,0,
	3,9,0,
	0,0,0
};

static float3x3 kernel1_0 =
{	
	0,0,0,
	0,9,3,
	0,3,1
};

static float3x3 kernel1_1 =
{	
	0,3,1,
	0,9,3,
	0,0,0
};

// Copies source into a new power of 2 destination texture, also pads the image with edge pixels
[numthreads(32,32,1)]
void MakePow2 (uint2 id : SV_DispatchThreadID)
{
	uint sW, sH;
    source.GetDimensions(sW, sH);	

	// Copies BOTTOM LEFT corner pixel
	if(id.x < offset.x && id.y < offset.y)
		dest[id] = source[uint2(0, 0)];
	// Copies BOTTOM RIGHT corner pixel
	else if(id.x >= sW + offset.x && id.y < offset.y)
		dest[id] = source[uint2(sW - 1, 0)];
	// Copies TOP LEFT corner pixel
	else if(id.x < offset.x && id.y >= sH + offset.y)
		dest[id] = source[uint2(0, sH - 1)];
	// Copies BOTTOM EDGE
	else if(id.y < offset.y)
		dest[id] = source[uint2(id.x - offset.x, 0)];
	// Copies LEFT EDGE
	else if(id.x < offset.x)
		dest[id] = source[uint2(0, id.y - offset.y)];
	// Copies TOP RIGHT corner pixel
    if(id.x >= sW && id.y >= sH)
		dest[id + offset] = source[uint2(sW-1, sH-1)];
	// Copies TOP EDGE
    else if(id.y >= sH)
		dest[id + offset] = source[uint2(id.x, sH-1)];
	// Copies RIGHT EDGE
    else if(id.x >= sW)
		dest[id + offset] = source[uint2(sW-1, id.y)];
	//Actual image
    else dest[id + offset] = source[id];


}

// TODO: Make it work.
[numthreads(32, 32, 1)]
void MakeNPow2 (uint2 id : SV_DispatchThreadID)
{
    dest[id] = source[id + offset];
}


[numthreads(32,32,1)]
void Analyze (uint2 id : SV_DispatchThreadID)
{
    dest[id] = (source[2*id+uint2(0.0,0.0)] + source[2*id+uint2(1.0,0.0)] + source[2*id+uint2(0.0,1.0)] + source[2*id+uint2(1.0,1.0)])/4;
}

// TODO: Make it work
[numthreads(32,32,1)]
void Synthesize (uint2 id : SV_DispatchThreadID)
{	
    uint sW, sH;
    source.GetDimensions(sW, sH);
	// Cast to float becasue HLSL is stupid and doesnt figure it out  by itself
	float2 uv = float2((float)id.x/sW, (float)id.y/sH);
	float2 texelSize = float2((float)1/sW, (float)1/sH);

	//dest[2*id+uint2(0.0, 0.0)] = source.SampleLevel(_LinearClamp, uv, 0);
	//dest[2*id+uint2(1.0, 0.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y), 0);
	//dest[2*id+uint2(0.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x, uv.y + texelSize.y), 0);
	//dest[2*id+uint2(1.0, 1.0)] = source.SampleLevel(_LinearClamp, float2(uv.x + texelSize.x, uv.y + texelSize.y), 0);
    dest[2*id+uint2(0.0, 0.0)] = ApplyKernel(id, kernel0_0);
	dest[2*id+uint2(0.0, 1.0)] = ApplyKernel(id, kernel0_1);
	dest[2*id+uint2(1.0, 0.0)] = ApplyKernel(id, kernel1_0);
	dest[2*id+uint2(1.0, 1.0)] = ApplyKernel(id, kernel1_1);
}

float4 ApplyKernel(uint2 id, float3x3 kernel)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * kernel[2][0];
	sum += source[id + int2(0.0 ,-1.0)] * kernel[2][1];
	sum += source[id + int2(1.0, -1.0)] * kernel[2][2];
	sum += source[id + int2(-1.0, 0.0)] * kernel[1][0];
	sum += source[id + int2( 0.0, 0.0)] * kernel[1][1];
	sum += source[id + int2( 1.0, 0.0)] * kernel[1][2];
	sum += source[id + int2(-1.0, 1.0)] * kernel[0][0];
	sum += source[id + int2( 0.0, 1.0)] * kernel[0][1];
	sum += source[id + int2( 1.0, 1.0)] * kernel[0][2];

	return sum/16;
}

float4 ApplyKernel0_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(-1.0,-1.0)] * 1;//kernel._m02;
	sum += source[id + int2(0.0 ,-1.0)] * 3;//kernel._m12;
	sum += source[id + int2(1.0, -1.0)] * 0;//kernel._m22;
	sum += source[id + int2(-1.0, 0.0)] * 3;//kernel._m01;
	sum += source[id + int2( 0.0, 0.0)] * 9;//kernel._m11;
	sum += source[id + int2( 1.0, 0.0)] * 0;//kernel._m21;
	sum += source[id + int2(-1.0, 1.0)] * 0;//kernel._m00;
	sum += source[id + int2( 0.0, 1.0)] * 0;//kernel._m10;
	sum += source[id + int2( 1.0, 1.0)] * 0;//kernel._m20;

	return sum/16;
}

float4 ApplyKernel0_1(uint2 id)
{
	float4 sum = 0;
 
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( -1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, 1.0)] * 3;
	sum += source[id + int2( -1.0, -1.0)] * 1;

	return sum/16;
}

float4 ApplyKernel1_0(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;
	sum += source[id + int2( 0.0, -1.0)] * 3;
	sum += source[id + int2( 1.0, -1.0)] * 1;
	
	return sum/16;
}

float4 ApplyKernel1_1(uint2 id)
{
	float4 sum = 0;

	sum += source[id + int2(0.0 ,1.0)] * 3;
	sum += source[id + int2(1.0, 1.0)] * 1;
	sum += source[id + int2( 0.0, 0.0)] * 9;
	sum += source[id + int2( 1.0, 0.0)] * 3;

	return sum/16;
}
